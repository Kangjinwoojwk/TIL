# 20190322 Summary

## 완전 검색 & 그리디

* 반복, 재귀
* 완전 검색 기법
* 조합적 문제
* 탐욕 알고리즘

재귀적 알고리즘의 특성 이해, 호출 학습, 완전 검색 개념 이해, 검색 통한 문제 해결

조합 문제, 완전 건색 방법 이해, 탐욕 알고리즘 개념과 특성 이해

### 반복과 재귀

* 반복과 재귀는 유사 작업 수행
* 반복은 수행 작업 완료될 때까지 반복, 루프
* 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용
  * 큰 문제 해결 할 더 작은 문제로 쪼개고 결과들을 결함
  * 재귀 함수로 구현
* 반복구조
  * 초기화, 조건검사, 반복할 명령문 실행, 업데이트

* 재귀적 알고리즘

  * 두부분, 하나 또는 그 이상의 기본, 하나 또는 그 이상이 유도

* 재귀 함수

  * 내부에서 직접 혹은 간접적 자기 자신 호출
  * 기본 부분과 유도파트로 구성
  * 반복구조 대비 간결하고 이해 쉬워, 익숙하지 않으면 어렵다고 느껴
  * 함수 호출은 프로그램 메모리 구조에서 스택 사용, 메모리 및 속도 성능저하

* 반복? 재귀?

  * 문제 고려, 반복이나 재귀 방법 선택
  * 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다.
  * 일반벅으로 재귀적 알고리즘은 반복 알고리즘 보다 더 많은 메모리와 연산 필요
  * 입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적

  ![20190322_1](C:\Users\student\TIL\수업정리 노트\20190322_1.PNG)

### 완전 검색 기법

문제 제시: baby-gin

* 고지식한 방법(brute-force)
  * 문제 해결 위한 간당하고 쉬운 접근법, 대부분의 문제에 적용가능
  * 상대적으로 빠른 시간에 문제 해결(설계), 요소가 작다면 유용, 학술적, 교육적 알고리즘 효율성 판단 척도
* 완전 검색으로 시작하라
  * 모든 경우의 수 생성하고 테스트, 수행속도 느리지만 해답 못찾을 확률 낮아
  * 그리디, 동적계획법의 기반, 효율적 알고리즘 찾을 수 있다
  * 우선 완전 검색 후 성능 개선 위해 다른 알고리즘 사용하고 해답 확인하는게 바람직

### 조합적 문제

문제 제시: 여행사 BIG sale! - 숙박비는 동일, 이동비용 문제, 순열 조합, TSP(외판원) 문제가 대표적

* 순열
  * 서로 다른 것들 중 몇개를 뽑아서 한줄로 나열, nPr로 표현, nx(n-1)x...x(n-r+1)
  * 다수의 알고리즘 문제들은 순서화 된 요소들의 집합에서 최선의 방법 찾는 것과 관련
  * N개의 요소엔 N!개의 순열 존재, 시간 복잡도 폭발적 증가
* 순열 생성 방법
  * 사전적 순서- 필요한 경우가 많다.
  * 최소 변경을 통한 방법- 이전 상태 이용해서 두 개씩만 교환

* 부분집합
  * 집합에 포함된 원소 선택, 다수 중요 알고리즘 들이 원소들의 그룹에서 최적의 부분집합 찾는 것
  * N개의원소를 포함한 집합의 부분집합은 2^n개, 지수적 증가로 시간 복잡도 증가
* 부분집합 생성 방법
  * 바이너리 카운팅을 통함 사전적 순서- 가장 자연 스러운 방법
* 조합
  * n개 원소 중 r개 순서 없이 골라내는 조합, nCr

### 탐욕 알고리즘

거스름돈 줄이기, 배낭 짐싸기 

* 최적해 구하는 근시안 방법, 머리 속에 떠오르는거 그대로, 할때마다 최적, 그게 최적이라는 보장 없어, 선택 번복 없어서 단순하지만 제한적, 최적해는 최소화, 해선택- 가능성 검사- 해검사
* Knapsack 유형
  * 0-1: 배낭에 물건 통째, 못 쪼갬
    * 완전 검색으로 모든 부분 집합 구한다- 초과 집합 버리고 나머지중 가장 큰거
    * 물건 증가하면 시간 복잡도 2^n
    * 비싼거 부터? 가벼운거 부터? 무게당 가격 높은거 부터? 전부 최적해 힘들어
  * Fractional- 물건 부붐 담기 허용, 쪼개기 가능
    * 탐욕으로 구할 수 있다. 무게당 가격 높은거 부터!
  * 회의식 배정하기
  * 선택활동 문제
* 탐욕 알고리즘 필수요소
  * 탐욕적 선택 속성 -> 탐욕적 선택이 최적해로 갈 수 있음을 보여라, 탐욕 선택이 늘 안전
  * 최적 부분 구조-> 최적화 문제 정형화, 하나의 선택을 하면 풀어야 할 하위 문제
  * =>원문제의 최적해=탐욕선택+하위문제의 최적해 임을 증명하라