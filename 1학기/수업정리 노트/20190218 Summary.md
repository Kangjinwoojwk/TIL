# 20190218 Summary

* 금요일거 풀이
* 구간합 문제
  * 브루트 포스로도 충분히 구한다.
  * 슬라이딩 윈도우 - 공통적으로 계산한 결과를 다음 계산을 구할때 사용한다.
    * M이 클수록 효과적

## 배열 2

* 2차 배열

  * 인덱스를 얼마나 잘 다루느냐 일뿐

  * 1차원 리스트를 묶어 놓은 리스트, 세로, 가로 길이 필요, 데이터 초기화 통해 변수 선언과 초기화 가능

  * 행 우선 순회, 열 우선 순회, 지그재그 순회

  * ```python
    for i in range(len(Array)):
        for j in range(len(Array[0])):
            Array[i][j+(m - 1 - 2 * j) * (i % 2)]
    ```

  * 델타를 이용한 2차 배열 탐색

  * ```python
    ary[0...n-1][0...n-1]
    dx[]<-[0, 0, -1, 1]# 상하좌우 페어만 맞으면 된다.
    dy[]<-[-1, 1, 0, 0]
    
    for x in range(len(ary)):
        for y in range(len(ary[x])):
            for I in range(4):
                testX<-x + dx[mode]
                testY<-y + dy[mode]
                test(ary[testX][testY])
    ```

* 부분집합생성

  * 바이너리 카운팅 소개

  * 부분집합 합 문제

    * 모든 집합 구하면 되는데 더 빠른 방법 찾고 싶어도 못찾고 있다. 2^n
    * 완전검색 외에 별 다른 방법이 없다.

  * 비트연산 - 빠르다

  * ```python
    if n % 2 == 0: print('짝수')
    else: print('홀수')
    if n & 1 == 0: print('짝수')#위와 동일한 코드
    else: print('홀수')
    lo, hi = 0, 10
    mid = (lo + hi)//2
    print(mid)
    mid = (lo + hi)>>1
    print(mid)
    ```

    * &, |, ^, <<, >> 연산

* 검색

  * 순차검색(O(n))
    * 비효율이지만 정렬 안되어 있을 땐 방법 없어, 끝까지 봐야 한다.
    * 정렬되어 있는 경우 중간에 더 큰 값 나오면 나올 수 있다.
  * 이진검색(O(logn))
    * 순서상 중간 위치를 찍어서 내가 찾으려는 키값과 비교
  * 해쉬(O(1)) - 메모리 공간이 많이 필요

* 인덱스

  * 메모리, 성능에서 효율성을 도모하기 위함

* 셀렉션 알고리즘

  * 저장되어 있는 자료로부터 k번째 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라고 한다.

* 선택정렬

  * 가장 작은(큰) 것을 가장 끝으로 해당 제외하고 다시 선택, 선택 한다. O(n^2)

* 실습1, 2