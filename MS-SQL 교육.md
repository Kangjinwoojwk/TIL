# MS-SQL 교육

## 성능요소

### SQL Server성능

#### 성능구성 요소

* 하드웨어
* 쿼리
* 어플리케이션 아키텍쳐A
* 데이터베이스 디자인
* SQL Server 및 데이터베이스 구성

#### 성능 이슈 발생 원인

* Gartner 연구

  * 성능 문제 원인 80%는 SQL구문
  * 15%는 DB설계
  * 5%는 적절하지 않은 하드웨어 구성

* 실제 DB어플리케이션 성능 이슈 발생시 일반적 대처 순서

  * 하드웨어 증설 고려 -> CPU, RAM추가
  * 여전히 X -> 인덱스 추가
  * 여전히 X->?

  개발한 SQL문과 어플리케이션 코드가 최적으로 동작하는지 점검하는 프로세스 필요

#### 주요 성능 이슈

* 리소스 병목 - 하나처럼 돌아 간다.
  * CPU
  * 디스크V
  * 메모리
* 차단 - 발생시 일반적으로 CPU 활용도 저하
* 교착 상태
* 대기

#### 성능 병목

* 전형적으로 문제 발생하는 영역
  * 리소스 사용
  * 트랜잭션 관리
  * 캐시 관리
  * 쿼리 실행 계획 재사용
  * 재컴파일

#### 대기

* 대기 유형 범위
  * 리소스 대기 : 리소스에 대한 액세스 요청시 잠금, 래치, 네트워크 및 디스크 I/O대기 포함
  * 큐 대기 : 작업자가 유휴 상태로 작업 할당 될 때까지 대기하는 경우
  * 외부 대기 : SQL Server 작업자가 확장 저장 프로시저 호출 또는 연결된 서버 쿼리 같은 외부 이벤트가 완료 될 때까지 대기 하는 경우
* 주요 대기 유형
  * PAGEIOLATCH : 주로 나오는 대기 유형

#### CPU 리소스

* 정렬 - 인덱스 이득과 오버헤드 비교
* 조인 - 임시 테이블 생성, work table
* 실행계획 재사용 미비 - SQL 컴파일, 재컴파일
* 재컴파일 - SQL Recompiles/sec
* IO관리 - 프로필러 스캔, 메모리 압박, DB 디자인

#### 메모리 추가가 도움이 되는 경우

* SQL buffer manager : Page Life Expectancy 수치가 낮은 경우 - 페이지가 캐시에 머무는 시간
* SQL Server Memory Manager: Memory Grants Panding 수치가 높은 경우
* 쿼리를 수행하는데 충분만 메모리가 확보되지 않으면 SQL Server가 쿼리 실행 않는다.

추가 후 Page Life Expectancy가 높아지면 도움이 됐다고 볼 수 있다.

#### IO 리소스의 사용

* 스캔

#### IO병목 발생 주요 원인

* 인덱스 또는 쿼리 최적화 미흡
* 데이터베이스 레이아웃
* 인덱스 관리 미흡

#### 디자인 이슈

* 

#### 잠금 종류와 잠금 리소스

* 잠금 종류
  * 공유 잠금
  * 배타 잠금
  * 업데이트 잠금
* 잠금 리소스
  * Row/Key
  * Page
  * Table
  * Extent
  * Database

#### 차단

* 차단 현상 감소 방안
* 차단 점검

#### 교착 상태

* 둘 이상의 작업이 서로 영구적 차단
* 일반적인 차단과 종종 혼돈
* 교착 상태 최소화
* 교착 상태 분석

#### 결론

* 시스템 성능 튜닝은 병목 찾아 해결, 사용량 극대화

## 성능 모니터링

#### 성능 모니터링 개요 - 필요항목

* 효과적인 성능 모니터링을 위한 필요 항목
  * 분명한 목표와 기준
  * 지속적인 성능 정보 수집 및 분석을 통한 추이 추적
  * 효과적인 모니터링 단계

#### 성능 모니터링 개요 - 수집 도구

* 윈도우
  * 성능 모니터
  * 작업 관리자
* SQL Server
  * SQLDIAG
  * SQL Server Profiler
  * SQL Server Management Studio 작업 모니터
  * SQL Server Management Studio 그래픽

#### 분석도구

* 성능 모니터 - perfmon
* ReadTrace
* T-SQL

#### 수집

* 디스크 대기 등 최적화로 대기 줄면 오퍼가 늘어서 CPU사용률이 올라간다?배치 증가
* full scan 전부 읽는 것, 배치와 연관 지어 볼것
* SQL Server:Memory Manager  Target Sever Memory와 Total Server Memory 일반적으로 동일, Target : 쓸 메모리 량, Toral 실제 쓰는 메모리 량

#### 추적 수집

* 성능 이슈 발생 원인 추적
* 잘못 된 추적 방법은 잘못된 추측으로

SQL Server Profiler로 이벤트 수집시 audit login, log out은 빼야 한다. 전부 수집시 부하커짐, 디스크 임시 공간에 로그 저장, 켜놓고 갈 경우 디스크 full위험, 끄면 용량 늘어난다. 시간별, 세션 아이디 설정으로 확인 가능, .trc파일 권한 문제, 쿼리 자원 사용 모니터링, 열때 제일 낮은 버전으로 열린다. SQLdiag.exe, 실제로 뭐가 있는건 XML, 수정 불가하니 복사 하여 수정 후 덮어쓰기, 인스턴스에 유저 명, 권한 설정, 쿼리 별로 어떤 걸 알지 확인

스트레스를 주고 해당 부하 확인, 

일반적인 query는 4part query가 기본

인스턴스 > db유저 > 스키마 > 테이블

인스턴스에 db유저로 로그인해서 기본 스키마의 테이블을 찾으니 테이블만 쓰던 것

사용자 속성 일반 스키마 확인시 설정을 볼 수 있다.

#### 동적 관리 개체(DMV)

* 실행 관련 - SQL들이 내부적으로 가지고 있는 것, 재시작 이후만
* 인덱스 관련
* 오브젝트 관련 - 통계가 있는데 어디서 쓰는 건지 보고 싶을때, 참조하는 프로시져 등
* OS관련
* 트랜잭션 관련 - Locks

dm_exec_query_stats는 그동안 수행된 query전부 보관

dm_exec_requests, 태스트 확인 시 50번 이하는 시스템 것, 시스템에 무언가 있는게 무엇인지 확인 하려고 할때 사용

#### 차단 정보 수집

```mssql
DBCC TRACESTATUS(-1) --DB돌고 있는 내역 보기
GO
```

리소스 부족시 다시 실행에 리소스 적게 드는 것을 죽인다.

DB종속성 확인

```mssql
USE DB1
GO
```

```mssql
XEC sp_configure 'show advanced options', 1 ; 
RECONFIGURE ; 
GO 
EXEC sp_configure 'blocked process threshold', 3 ; 
RECONFIGURE ; 
GO
```

모니터링 툴을 쓰면 지난 계획을 알 수 있다는 장점이 있다.  모르게 나는 에러 알 수 있다.

#### 교착 상태 정보 수집

#### 대기 정보 수집

초기화 후 수집 가능

#### 인덱스 조각화 정보 수집

#### 데이터베이스 파일 정보

```mssql
SELECT * FROM sys.dm_io_virtual_file_stats(NULL, NULL); --DB번호, 테이블번호
GO
```

sp_who2, who is active, sp_lock, sp_spaceused - 사이즈 나온다. DB, 테이블, SP_monitor

## 인덱스 및 통계

인덱스만으로도 많은 성능 개선 가능

### 인덱스

#### 인덱스란?

* 빠른 검색을 위한 데이터 구조
* 테이블 또는 인덱싱된 뷰의 검색 속도 향상
* 테이블이나 뷰에 있는 하나 이상의 열을 키로 포함
* 키는 SQL 서버에서 키에 포함된 B-트리 구조로 저장

#### 클러스터형 인덱스 구조

* B트리, 밸런스 트리 어디로 가든 비용 비슷

#### 인덱스 유형

* 클러스터형 인덱스
  * 키값 기반 데이터 행 정렬 저장
  * 테이블당 하나, 클러스터 인덱스는 다수 가능
  * 인덱스 포함 테이블 -> 클러스터형 테이블
  * 포함 되지 않은 테이릅 -> 힙 테이블
* 비 클러스터형 인덱스 - 데이터가 없다. 검색 속도 향상 위함
  * 데이터 행과 독립적인 인덱스 - 데이터와 무관
  * 인덱스 키 값 존재, 해당 키 값 포함 데이터행에 대한 포인터 존재
    * 클러스터형 테이블 -> 클러스터형 인덱스
    * 힙 테이블 -> 행의 포인터 -row id가지고 있다.
  * 포괄 열 인덱스 생성가능

#### 클러스터형 인덱스 구조

* 인덱스 ID가 1이면 클러스터형, 0이면 힙

#### 비클러스터형 인덱스 구조

형태는 똑같이 B-트리, 행 로케이터 포함된다. 

#### 클러스터형과 비클러스터형 인덱스 구조 차이점

키기반 순서, 순서 X, 데이터 페이지 구성, 인덱스 페이지 구성, 행로케이터 불필요, 필요

#### 클러스터형 인덱스 선정 기준

초기 primary키 등록시 자동으로 인덱스 선정

* 일정한 범위의 값을 반화하는데 자주 참조되는 열에 생성
* 클러스터형 인덱스의 길이가 길어질수록 비클러스터형 인덱스의 길이가 길어짐
* 정적인 열에 생성
  * 변경되지 않은 열에 생성 -> 성능향상
  * 변경되는 열에 생성하는 경우 -> 키에 대한 업데이트 작업 비용 증가
  * 클러스터형 인덱스가 필요한 후보가 없으면? ->identity열에 클러스터형 인덱스 생성 고려 - 중간에 끼지 않을 만한 값
* 고유 값으로 생성
  * 고유 값 -> 추가적인 오버헤드 없음
  * 중복 값 -> insert시에 SQL Servre가 4바이트의 uniquifier자동으로 추가(시간, 공간 비용 발생)

#### 테이블 스캔과 인덱스 검색

인덱스 스캔, 다 읽지 않아도 되도록!

일부 검색 건너 뛰고 뒤로 쭉 검색 하도록 index seek-실행계획, 데이터 페이지는 뒤에 있는건 다 간다.

논 클러스터면 전부 검색으로 간다. 그럼 뭐하러...

#### 인덱스 생성 기본 지침

인덱스 꼭 생성이 좋은 것은 아니다. 인덱스 만들어도 큰 변함 없는 경우 많다. 대체적으로 집어낼때 1% 정도 되야 쓸지 말지 고민 필요한 수준, 첫번째 열이 무엇인가? 가 중요하다. 

* 쿼리 우선 순위
* WHERE절 각 부분의 선택성
* 인덱스 생성 결정
* 인덱스 생성열 결정
* 복합 경우 최적 순서 결정
* 쿼리를 직업 수행 -> 테스트!

#### 인덱스 생성 방법

인덱스 생성은 기본이 정렬, lock 후에 한다. blocking 최소화 필요

* 단순 NONCLUSTERED INDEX
* 고유 UNIQUE INDEX - primary key 지정시 무조건 이것으로 생성, 다른 칼럼도 unique 설정 가능, null도 unique설정 가능 단 null가진 행은 하나만 가능, 오라클 처럼 무시X
* 포괄 열 인덱스 NONCLUSTERED INDEX
* 압축 인덱스 NONCLUSTERED INDEX

인덱스 테이블 만들면 일단 heap만 생기고 아무 것도 없다.

lookup비용 다수 발생, DB에 갔다 오는 게 많은 것, 인덱스에 찾는 내용 포함시 look up 안 일어 난다. covered index, 빈도수 많아져서 look up 줄일 수 있다면 covering하는게 좋다. noncluster인데 무조건 coverd index 만들면 index계속 커진다. 실제보다 index가 더 커지기도 한다. cost base optimize, 비용 늘 따져서 적은 쪽으로 안댁수 강제로 쓰게 하는 것도 가능, 344 vs 2560, index키만으로 된다면 include안하고 하는게 낫다면 include

데이터 이전시 IDENTITY 칼럼, 원칙은 변경 불가, 실제론 된다.

#### 필터링된 인덱스/통계

예시)SMS 송신 테이블, 보냈나 안 보냈나 Y, N, Y는 필터링 의미 적어, N은 의미 커, 이걸로 필터링 된 인덱스는 의미 크다. 

#### 성능 위한 인덱싱

* 테이블 용도 OLTP? OLAP? 복합? => 클러스터형 인덱스 결정
* 제약 조건 생성 - primary key, unique key, check
* Foreign key 제약 조건 인덱스 추가 - join 발생시 추가가 이득
* 특정 쿼리 성능 증가 -우선 순위, 자주실행
* 선택성
* Search Arguments 변화, 선택성 낮은 경우 쿼리 성능 개선
  * 인덱스 커버링
  * 집계
  * 인덱스 된 뷰

#### 최적의 성능 유지

* 인덱스 관리 : 인덱스의 효율적인 성능 유지
  * 인덱스 재구성
    * 테이블 사용
    * 로그 공간 다수 사용 -> 왜? 계속 증가, 재구성시 용량 줄어든다. 
  * 인덱스 재작성
    * 경우 따라 테이블 사용 불가
    * 완전 재구성

```mssql
--뭐가 좋을지는 상황 따라
ALTER TABLE AAA REBUILD;
GO

CREATE CLUSTERED INDEX CX_111 ON AAA(COI1)

DROP INDEC CX_111 ON AAA
GO
```



쓸수록 인덱스 조각화 일어난다. 오래 쓰면 99% 조각화 나 있다. 조각화 따라 정하거나 한다. 시스템 특성을 확인해야 한다. 재작성은 테이블 잠구고 한다. 리빌드 자주하는게 좋지만 용량이 크고 테이블을 계속 써야하면 문제 서버 스펙 따라 성능 바뀐다. 

## 통계

옵티마이저가 옵티마이징 할때 쓴다.

#### 통계 생성

#### 통계 관리

통계 오래 되면 자동 갱신, 속성>옵션>자동>통계 자동 업데이트 20% 바뀐다 든지

통계를 비동기적으로 자동 업데이트 : 쿼리 할때 통계 업데이트가 오래 됐으면 통계 업데이트

최신 통계 일자 확인

* 통계를 사용할 수 없는 경우
  * 통계 생성 및 갱신 설정 OFF
  * 통계 사용 불가로 쿼리 작성
  * 옵티마이저가 쿼리 저장 불가

#### 문자열 요약 통계

점점 좋아지고 있다.

## 실행계획

실제로 옵티마이저가 어떻게 실행할지 계획 하는 것

재컴파일 : 플랜 캐시 찾아서 있으면 실행 계획이 유효한지 판단 후 해당으로 실행

유효하지 않으면 재컴파일

#### 실행계획 캐싱

모든 쿼리는 캐싱 된다. 효율적이냐 아니냐의 차이만 있을 뿐

* 다차원 캐싱

실행 계획은 재사용하는게 좋다. 

#### 재컴파일 발생 원인

- 스키마 변경(인덱스 변경, 생성, 삭제, 칼럼 생성 등)
- SET옵션(일괄 처리 내부에서 실행 계획 재사용에 영향을 미치는 경우)
- 참조 테이블 데이터 변경

#### 재컴파일 발생 원인 - 실행 계획 제거

- DBCC FREEPROCCACHE - 실행 계획 전부 지우라는건 운영에서 X 개발에서나
- DB수준 변경 작업

#### 재컴파일 확인 도구 및 명령어

Auto-Param Attmpts/sec, Batch Requests/sec,  Failed Auto-Params/sec, Safe Auto-Params/sec,  SQL Compilations/sec, SQL Re-Compilations/sec,  Unsafe Auto-Params/sec

제일 확실

활성쿼리 통계 포함하면 볼 수 있으나 운영에서는 부담, 비권장

예상 실행 계획과 실제 실행 계획이 늘 같지는 않다.

관리 > 확장 이벤트시 생성 등 가능

SHOWPLAN으로 플랜 볼 수 있다.  행수 나온다. 

#### 실행 계획 제어 방법

원래는 옵티마이저대로 한다. 늘 Best 아니다. join늘고 where많아지면 뭣부터 해야 될지, 뭣부터 join? 뭣부터 where? 기반은 where부터

#### 테이블 힌트

테이블이 어떤 건지 힌트를 줄 수 있다.

- 격리 수준 
  - readuncommitted
  - readcommitted
  - readpast
  - repeatableread
  - snapshot
  - serializable
- 잠금 : lock이 늘면 아래 단으로 늘어 난다. lock이 줄어 드는 거처럼 보인다. 실제로 많진 않다.
  - rowlock
  - paglock
  - tablock
  - updlock select할때 걸면 업데이트 할테니 건드리지 말라는 것
  - xlock
- 인덱스 하나 혹은 여러개 줄 수 있다.
  - index=인덱스명
  - index(인덱스명, 인덱스명)
- 조인 힌트
- 쿼리힌트 : 쿼리 마지막에 option으로 입력하여 주는 것

upt할때 락이 걸리면 readcommited로 피하는것, readpast쓰면 아무 것도 안나온다.

어거지로 다른 인덱스 사용하면 해당 인덱스를 스캔 한다 왜? 실제로 인덱스에 포함되는 것이 join에서 이용 되기 때문이다. 어딨는지 모를 뿐, 스캔으로 찾아 내서 가는 것 전부 읽는다.

인덱스를 두개 쓰라고 하면? 두개 쓴다. 상황따라 어느게 좋은지 달라진다.

강제 스캔 forcescan 쓰면 강제로 스캔, 다 읽는다. 쓰는게 좋다는 근거만 있으면 된다.

머지가 좋다고 판단하면 머지로 실행, 이 경우 1번만 읽고 다 가져 온다. 매번 읽는 것보다 낫다? 뜯어 보면 머지가 좋은거 같은데 실제 뜯어 보면 머지가 일일이 연산 중, 낫지 않다.

optimize for - 값에 따라 실행 계획이 변화 인덱스 할 수 있어도 스캔인 경우 있다. 왜? 스캔계획이라서 초기화 후 하면 다시 반대 된다. 항상 그 값이 들어 온거처럼 실행계획을 세우라는 게 optimize for다. 

#### 계획지침

쿼리를 수정 할 수 없는 시스템에서 쿼리의 실행 계획을 짜주려고 할때 하는 것이다. 

#### 카디널리티 예측

예상 행수 계산, 2012에서 2014로 하면서 바뀐것, 옮기면 실행계획 틀어진다. 속성 > 옵션> 호환성 수준을 낮추면 바꾸기 전으로 옵티마이저 돌아 간다. 다 좋아졌는데 한두개만 문제면? 해당 쿼리를 찾아서 9481or force_legacy_carcinality_estination 서버 업그레이드 하거나 했다면 고려

실행 계획 재사용은 그대로 돌려야 한다. 글자 하나만 달라져도 실행계획 다시 세운다. 스페이스바 새로 넣거나 대소문자만 바꿔도 새로 세운다. 

## 데이터 형식

데이터 형식을 모두 알 필요는 없다. 자주 쓰는 것들을 확인하고 하는 편이 효율성에 영향이 크다.

수치, 날짜 및 시간, 문자열, 이미지, 이진 문자, 계층 구조, xml, 공간데이터

nchar, nvarchar 같이 n 붙은 형식은 유니코드로 저장, 한국서 저장시 cias, cs 대소문자 구분, 구분 x이다. 옮길때 에러 난다. 조인도 안 된다. 영문과 코리아 완성차이

money 타입 우리나라에서 쓰는 경우 없다. 저장은 숫자로 보일땐 달러로

문자는 1페이지, 8천자 까지 가능 varchar(max)는 최대 2GB, varchar는 가변이라 실제 길이 모른다. 몇자리인지 2byte 추가 공간 있다. 네자리 이하문자열이면 가변이라도 고정길이 문자열 데이터 형식 권고, 길이 최댓값은 큰데 실제 데이터길이가 짧은 행의 비율이 많으면 varchar가 저장소측면 유리

유니코드 저장시 n 빼고 넣으면 깨진다. 유니코드는 다수 언어 쓸때 쓰는 것

데이터 길이, 크기 보는 함수

기존에 있던 datetime, smalldatetime은 연도가 1753년~ 1900년~이렇다. 역사적인 무언가를 저장 할때는 좋지 않다. 

어떤 데이터 타입을 우선 할 것인가? 시간데이터가 우선 순위가 많이 높다. 문자는 주로 낮다. 문자를 숫자로 바꿔서 연산한다. 유니코드가 non유니코드보다 높다. java랑 연결시 string 전부 nvarchar로 넘어간다. 근데 그냥 varchar로 선언한게 많다. 다 nvarchar로 변경해서 비교, 성능적으로 안 좋다. java에서 nvarchar로 안 받게 하거나 nvarchar를 쓰면 괜찮다. 

### 암시적 형 변환

명시적 변환: FORMAT, CONVERT

우선순위가 높은 쪽으로 암시적으로 변한다. 숫자는 일단 int

datetime 정확도 3/1000, 중복이 발생 할 수 있고 다음 날이 될수도 있다. smalldatetime은 분까지만 의미

타입 사용자 정의 생성하면 해당한 타입으로 만들 수 있다. 

계층구조 저장하는 hirokyID

데이터가 암시적으로 변하면 원하던 것과 다른 결과들이 나온다. 

## 트랜잭션

all or nothing으로 처리되어야 하는 작업 단위에서 처리

default는 오토커밋이다. 보통 쓰는 건 명시적 트랜잭션, 암묵적- 오라클 방식MS에선 안씀.

trancount 0이 되어야 잠금 모두 해제, 트랜잭션 종료

#### 트랜잭션 격리 수준

* read uncommited : 커밋 되지 않은 것도 읽겠다. 업데이트 중인건 buffer cache에 있다. dirty라고 부른다.
* read commited : 기본, 이미 commit된 것만 읽겠다.
* repeatable read : 트랜잭션 완료 될 때까지 데이터 공유 잠금 유지, 조회 중인 것 수정 불가상태 만듬
* serializable : 조회 데이터 영역 전체 잠금, insert도 차단, 팬텀 리드도 방해
* snapshot
  * read_commited_snapshot : db전체
  * allow_snapshot_isolation : 밑과 함께 사용
  * set transaction isolation level snapshot : 내가 본 것들 lock

##### 테이블 힌트 - readuncommitted(nolock)힌트

이걸 쓴다고 쿼리 성능이 개선 되는 것은 아니다. 차단 감소, 돌아 갈 수 있다.

```mssql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
```

##### 테이블 힌트 - repeatableread힌트

트랜잭션 완료까지 변화 불가 생성 가능

트랜잭션 시작하면 trancount 1씩 커짐, commit하면 1 작아짐 rollback하면 0

암시적 트랜잭션 시작은 아무것도 안한 상황에선 trancount 안 커짐

xact_anort set 옵션 비활성화, OFF, t1과 t1를 외래로 받는 t2 1,3있고 1,2, 3을 insert하면? 1, 3은 insert성공 2만 롤백, 뭔가 잘못 됐다...

xact_anort set 옵션 활성화, ON, 다 안된다. 전체 롤백

```mssql
SET LOCK_TIMEOUT 3000 --3초이상 안 기다림, 죽인다. -1이면 기다림

EXEC sp_lock
GO

dm_exec_requests
```

블락킹 확인 가능한 것들 방법은 다양, 데드락 모니터 그래프로도 보여준다.

##### xact_state

해당 값으로 뭘 할지 정하는 것

### 잠금

모든 시스템에 잠금 있다. 이는 자연스럽다. blocking 발생이 문제 blocking 최소화가 필요 없으면 좋다. 자연스런 잠금 줄여서 blocking 줄여야한다.

deadlock은 빨리 잡힌다.

#### 잠금 모드

앞에 I가 붙은 것은? intent, 인위적으로 잡아 놓은 락

key가 있던 없던 row하나만 잡는건 KEY로 나온다.

row-page-table-extent-database 순으로 올라간다.

잠금테이블 힌트

nolock은 쓰지 말것, readuncommitted를 쓸 것, with 안써도 돌아가지만 with쓰는 것이 표준 with 쓰고 옵션 주는 것에 습관 가질 것, hint 자체가 안쓸 수 있으면 안 쓰는게 좋다. 확신 들때만 써라. 특히 index 힌트, 조각난다.

#### 차단blocking

최소화 방법? 인덱스 최적화, 쿼리 최적화, 트랜잭션 가능한 짧게 유지하도록 작성, 가능한 낮은 트랜재션 격리 수준 사용, 테이블 분할, 스냇숏 격리 수준 도입 고려, 재컴파일 유의, 힌트 사용 유의

인덱스는 조각 나고 사라지기도한다.update, delete에서 인덱스는 방해 되기만 하기도 한다. 

쿼리 짤때 자동 타입캐스팅 이용하면 전부 들어간다.

select엔 트랜잭션 굳이 필요 없다. 격리 수준 높을수록 차단, 교착상태 발생 가능성 많아진다.

#### 데드락 상태 우선 순위 지정

지정 가능

## 집계처리

avg, sum, count, max, min, null 포함 미포함 count(*)만 포함 기본은 all

GROUP BY는 partition by와 비슷

count 옵티마이저 cbo, 클러스트인덱스를 읽으면 비용이 많이 드니 non클러스트 인덱스를 읽는다. 

count_big : 셌는데 21억 넘으면 처리해줘야 한다.

approx_count_distinct 고유한 null이 아닌 값의 대략적 개수 반환

오라클도 MS도 사람이 어떤 처리를 하느냐에 따라 다르다.

GROUP BY

* Roll up - 소계, 전체 sum
* cube - 소계 밑으로 뺌
* sets - 두개의 group by 한번에

Over partition하면 하나당 partition이 생긴다. 범위를 확실히 정하는것, 안쓰면 grouping한것 전체에서 본다. 변하는 평균을 구하는 것 한번에 할 수 있게 해준다. 누적합

expand views 옵션, views쓰지 말고 원래 테이블을 읽어라, with(index(0)) 테이블 다 읽어라(0은 인덱스의 힙부분), view를 쓰면 더 빠르다. NOEXPAND는 view읽으라는 것, view는 바로 바로 반영 해당하는 처리 있다.

테이블 생성시 칼럼 계산 한 값이 들어가게 할 수 있다. 이럴때 insert에 삽입할 칼럼은 다 쓰는게 좋다. 

## 중복처리

UNION, EXCEPT, INTERSECT

UNION은 합치기, 열의 개수, 순서 동일해야 한다. 호환 되면 형식 다를 때도 union가능하다. UNION은 중복행 제거, UNION ALL은 중복행 포함

except는 차집합, intersect는 교집합, 개수와 순서 동일, 형식 호환 필

#### MERGE 구문

update와 insert 한번에 처리

트리거 실행시 가장 테이블 생성 된다, inserted, deleted(update는 둘다 생김)

### 오류처리

기본 에러처리 @@ERROR, 이게 0이면 오류가 없다. 

```mssql
SELECT @ErroCode = @@ERROR -- 에러가 났는지
@RowCountVar = @@ROWCOUNT; --몇 개나 적용 됐는지, 업데이트가 되야 하는데 0이면 그것도 ERROR
```

##### Try-Catch

208Error 존재하지 않는 테이블, Catch로 빠지면 rollback 필수, xact_state나 trancount를 통해 커밋, 롤백 선택 체크

Update직후에 하지 않으면 rowcount는 다음것의 rowcount잡는다.

raiserror는  에러가 났을때 raiserror위치를 잡는다 throw를 추가하면 어디서 무슨 에러인지 알려준다. 

## T-SQL Best Practices

하드웨어, 옵티마이저 업그레이드 점점 빨라져, 트래픽 많을 수록 느려진다. 최적화된 쿼리가 중요한 이유! 적은 비용으로 효율적인 시스템으로 개선

#### 저장 프로시저 저장 권장

##### 이유

* 실행계획 재사용 가능성 높다
* ad-hoc 쿼리 대비 네트워크 트래픽 감소 도움
* ad-hoc 쿼리 대비 실행권한 관리 통한 관리 용이
* ad-hoc 사용시 SQL INjection 가능성 커짐
* 업무로직 모듈화, 일관성 있는 로직 구현 용이
* 테이블 구조 변경필요한 경우에도 개체 종속성 기능 사용 개체 파악 용이
* 업그레이드시 호환 불가 쿼리 검출 진단 용이

```mssql
SET NOCOUNT ON --사용 권장, select 이용시 메세지 일일이 안 받음
```

##### 유의점

* 저장 프로시저 생성시 SP_쓰지 말것, 시스템 저장으로 판단, 유저이름 권장

* 파라미터 유효성 시작에 검사 권장, 나중에 rollback하면 비효율적
* where에 로컬 변수 사용 비추천, 옵티마이저가 로컬 변수 인지 불가
* 네트워크 라운드 트립 최소화

옵티마이저는 top코드를 좋아한다. 루프가 아닌 집합으로 처리하면 빠를 수 있다. 쿼리 작성 후 옵티마이저 동작 확인필요

DB에서 가져오는 파라미터에는 아무짓도 말고 뒤를 어떻게 바꿀지 생각하라, 형이 일치하도록

SELECT에 가증하면 컬럼 이름 지정, * 쓰지 마라, Index커버링 된다. look up 즐일 수 있다. 늘 그렇지는 않다. lookup 발생하면 다 읽는다.

exists과 in in은 전부 다 읽는다. exists는 있기만 하면 된다. 다 읽을 필요 X, 있는지 없는지만 볼거면 exists

조인 가능하면 서브쿼리 쓰지 않는게 좋다.

TOP을 쓰면 다 가져 오지 않으니 좋다.

@@rowcount이용

OUTPUT

트리거는 트랜잭션의 일부이므로 사용 유의, 어떤 칼럼 업데이트 인지도 확인 하고 발동 가능