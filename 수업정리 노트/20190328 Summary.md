# 20190328 Summary

## 그래프

* 그래프 기본
* 그래프 탐색
* 서로소 집합들 - 자료 구조
* 최소신장트리 - Prim, kruskal - 탐욕
* 최단 경로 - dijkstra - 탐욕-> bellman-Ford, Floyd-warshall - DP

실 세계 문제를 그래프로 추상화해서 해결하는 방법 학습

​	BFS, DFS, 상호배타 집합 자료구조, 최소 신장트리 알고리즘, 최단 경호 찾는 방법

### 그래프 기본

* 그래프
  * 아이템들과 이들 사이 연결 관계 표현
  * 정점들의 집합과 연결하는 간선 집합으로 구성 된 자료 구조
  * 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N관례를 가지는 원소 들 표현 용이
* 그래프 유형
  * 무향그래프
  * 유향그래프
  * 가중치그래프
  * 사이클 없는 방향그래프
  * 완전그래프- 정점들에 대해 가능한 모든 간선을 가진 그래프
  * 부분 그래프- 완전 그래프에서 일부 정점, 간선 제외
* 인접 정점
  * 인접- 두개의 정점에 간선 존재
* 그래프 경로
  * 간선들을 순서대로 나열
  * 한 정점을 최대 한 번만 지나는 경로를 단순결로라고 한다.
  * 시작한 정점에서 끝나는 경로를 사이클이라고 한다.
* 그래프 표현
  * 가선 정보 저장 방식 - 메모리, 성능 고려 결정
  * 인접행렬 - |V|x|V|크기 2차원 배열 이용 간선 정보 저장, 배열의 배열
  * 인접 리스트- 정점마다 해당 정점 나가는 간선 정보 저장
  * 간선의 배열- 배열에 연속적으로 저장
* 인접 행렬
  * 두 정점을 연결하는 간선의 유무를 행렬로 표현
    * |V|x|V| 정방 행렬
    * 행 번호와 열번호 그래프의 정점에 대응
    * 두 정점이 인접되어 있으면 1, 아니면 0으로 표현
    * 무향 그래프- i번째 행의 합 = i번째 열의 합 -  Vi의 차수
    * 유향 그래프 - 행i의 합 = Vi의 진출 차수, 열 i의 합 = Vi의 진입 차수
  * 단점? 메모리를 엄청 많이 쓴다.
* 인접 리스트
  * 각 정점에 대한 입점 정점들을 순차적으로 표현
  * 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장

### 그래프 순회(탐색)

* 깊이 우선, 너비 우선
* 스택과 큐

### 서로소 집합들

* 서로소 또는 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합

* 특정 메버를 통해 각 집합들을 구분, 대표자

* 상포배타 집합 표현 - 연결 리스트, 트리

* 상호배타 집합 연산 -  Make-Set(x), Find-Set(x), Union(x, y)

* 상호 배타 집합 표현 - 연결리스트

  * 같은 집합의 원소들은 하나의 연결리스트로 관리한다.
  * 연결리스트의 맨 앞의 원소를 집합의 대표 원소로 삼는다.
  * 각 원소는 집합의 대표원소를 가리키는 링크를 갖는다.

* 상호배타 집합 표현 - 트리

  * 하나의 집합을 하나의 트리로 표현한다.
  * 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다.

* 상호배타 집합에 대한 연산

  * Make-Set(x):유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산

  * Find_Set(x):x를 포함하는 집합을 찾는 연산

  * Union(x, y):x와 y를 포함하는 두 집합을 통합하는 연산

  * 문제점: 밑으로만 메달면 find할때 너무 길어진다. 전부 root를 가르키게 하면 연산 짧다.

    그냥은 이렇게 못하니까 다른 방법을 사용

  * 연산의 효율을 높이는 방법

    * Rank를 이용한 Union
      * 각 노드는 자신을 루트로 하는 subtree의 높이를 랭크라는 이름으로 저장
      * 두 집합합칠때 rank가 낮은 집합을 rank가 높은 집합에 붙인다.
    * Path compression
      * Find-Set중 만나는 모든 노드 들이 직접 root가리키도록 바꿈

### 최소신장트리(MST)

* 그래프에서 최소 비용 문제- 모든 정점을 연결하는 간선들의 가중치 합이 최소가 되는 트리

  두 정점 사이의 최소 비용의 경로찾기

* 신장 트리 -  n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n -1개의 간선으로 이루어진 트리

* 최소 신장 트리 -  무향 가중치 그래프에서 신장 트리 구성하는 간선들의 가중치의 합이 최소

* MST 표현

  * 그래프, 간선들의 배열, 인접 리스트, 부모 자식관계와 가중치에 대한 배열

* Prim 알고리즘

  * 하나의 정점에서 연결 된 간선 들 중에 하나씩 선택하면서 MST 만들어 가는 방식
    * 임의 정점 선택- 인접정점 들 중 최소비용 간선 존재 정점 선택- 모두 선택 될때까지 반복
  * 서로소인 2개의 집합 정보 유지, 선택, 비선택

* KRUSKAL 알고리즘

  * 간선을 하나씩 선택해서 MST를 찾는 알고리즘

    * 최초, 모든 간선 가중치 따라 오름차순
    * 가중치가 가장 낮은 간선부터 선택하면서 트리 증가
    * n - 1개의 간선이 선택 될때까지 2반복

    ```python
    >>> student_tuples = [
    ...     ('john', 'A', 15),
    ...     ('jane', 'B', 12),
    ...     ('dave', 'B', 10),
    ... ]
    >>> sorted(student_tuples, key=lambda student: student[2])   
    # sort by age
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
    ```

### 최단 경로

* 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로

* 하나의 시작 정점에서 끝정점까지의 최단 경로, 다익스트라(음 가중치x), 벨만-포드(음 가중치o)

* 모든 정점들에 대한 최단 경로- 플로이드 워샬 알고리즘

벨만-포드와 플로이드도 가중치가 -인 싸이클이 있는 것은 안된다.

* Dijkstra 알고리즘
  * 시작 정점에서 거리가 최소인 정점 선택하며 최단 경로 구한다.
  * 시작정점->끝정점 최단 경로에 정점 x존재, 최단 경오는 s부터 x, x부터 t의 최단 경로로 구성
  * 탐욕기법 사용한 알고리즘, 프림과 유사

## 다익스트라 알고리즘

* 시작 정점에서 거리가 최소인 정점 선택하며 최단 경루 구하기, 탐욕적, 프림과 유사
* 최간 경로상 지점 선택
* 출발점 r에서 정점 v까지 최단 경로 가중치 합 d[v] 이후 동시에 갈 수 있는 곳은 d[y], d[x]에서 가중치 계산해서 더 작은 값을 가지는걸 취한다.

